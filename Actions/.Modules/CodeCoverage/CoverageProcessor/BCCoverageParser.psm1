<#
.SYNOPSIS
    Parses Business Central code coverage files
.DESCRIPTION
    Reads and parses the code coverage output files generated by BC CodeCoverage exporters.
    Supports two formats:
    - CSV (.dat): XMLport 130470/130471 - ObjectType,ObjectID,LineNo,CoverageStatus,NoOfHits
    - XML: XMLport 130007 - Full XML format with all code lines including not covered
    Encoding can be UTF-8 or UTF-16 LE.
#>

# Object type mapping from BC internal IDs to names
$script:ObjectTypeMap = @{
    1  = 'TableData'
    3  = 'Table'
    5  = 'Codeunit'
    6  = 'XMLport'
    7  = 'MenuSuite'
    8  = 'Page'
    9  = 'Query'
    14 = 'Report'
    22 = 'TableExtension'
    23 = 'PageExtension'
    35 = 'PageCustomization'
    37 = 'Enum'
    38 = 'EnumExtension'
    40 = 'Profile'
    42 = 'ControlAddIn'
    44 = 'PermissionSet'
    45 = 'PermissionSetExtension'
    46 = 'ReportExtension'
    47 = 'Interface'
}

# Coverage status mapping
$script:CoverageStatusMap = @{
    0 = 'Covered'
    1 = 'NotCovered'
    2 = 'PartiallyCovered'
}

# Reverse mapping from object type names to IDs
$script:ObjectTypeNameMap = @{
    'tabledata'              = 1
    'table'                  = 3
    'codeunit'               = 5
    'xmlport'                = 6
    'menusuite'              = 7
    'page'                   = 8
    'query'                  = 9
    'report'                 = 14
    'tableextension'         = 22
    'pageextension'          = 23
    'pagecustomization'      = 35
    'enum'                   = 37
    'enumextension'          = 38
    'profile'                = 40
    'controladdin'           = 42
    'permissionset'          = 44
    'permissionsetextension' = 45
    'reportextension'        = 46
    'interface'              = 47
}

<#
.SYNOPSIS
    Gets the object type ID from a name
.PARAMETER ObjectTypeName
    The object type name (e.g., "Table", "Codeunit")
.OUTPUTS
    Integer ID or 0 if not found
#>
function Get-ObjectTypeId {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ObjectTypeName
    )
    
    $lower = $ObjectTypeName.ToLower().Trim()
    if ($script:ObjectTypeNameMap.ContainsKey($lower)) {
        return $script:ObjectTypeNameMap[$lower]
    }
    return 0
}

<#
.SYNOPSIS
    Parses a BC code coverage file (auto-detects CSV or XML format)
.PARAMETER Path
    Path to the coverage file (.dat for CSV, .xml for XML)
.OUTPUTS
    Array of coverage entry objects with ObjectType, ObjectID, LineNo, CoverageStatus, Hits
#>
function Read-BCCoverageFile {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    
    if (-not (Test-Path $Path)) {
        throw "Coverage file not found: $Path"
    }
    
    # Detect format based on file extension or content
    $extension = [System.IO.Path]::GetExtension($Path).ToLower()
    
    if ($extension -eq '.xml') {
        return Read-BCCoverageXmlFile -Path $Path
    }
    
    # For .dat or other extensions, check content to detect format
    $bytes = [System.IO.File]::ReadAllBytes($Path)
    $contentStart = ""
    
    # Get first few characters to detect XML
    if ($bytes.Length -ge 2 -and $bytes[0] -eq 0xFF -and $bytes[1] -eq 0xFE) {
        # UTF-16 LE
        $contentStart = [System.Text.Encoding]::Unicode.GetString($bytes, 2, [Math]::Min(100, $bytes.Length - 2))
    } elseif ($bytes.Length -ge 3 -and $bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF) {
        # UTF-8 with BOM
        $contentStart = [System.Text.Encoding]::UTF8.GetString($bytes, 3, [Math]::Min(100, $bytes.Length - 3))
    } else {
        # No BOM, assume UTF-8
        $contentStart = [System.Text.Encoding]::UTF8.GetString($bytes, 0, [Math]::Min(100, $bytes.Length))
    }
    
    if ($contentStart.TrimStart().StartsWith('<?xml') -or $contentStart.TrimStart().StartsWith('<CodeCoverage')) {
        return Read-BCCoverageXmlFile -Path $Path
    }
    
    return Read-BCCoverageCsvFile -Path $Path
}

<#
.SYNOPSIS
    Parses a BC code coverage XML file (XMLport 130007 format)
.PARAMETER Path
    Path to the XML coverage file
.OUTPUTS
    Array of coverage entry objects
#>
function Read-BCCoverageXmlFile {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    
    $coverageEntries = [System.Collections.Generic.List[object]]::new()
    
    try {
        [xml]$xml = Get-Content -Path $Path -Encoding UTF8
    }
    catch {
        # Try Unicode encoding
        [xml]$xml = Get-Content -Path $Path -Encoding Unicode
    }
    
    # XMLport 130007 format: <CodeCoverage><CodeLine>...</CodeLine></CodeCoverage>
    # Each CodeLine has: ObjectType, ObjectID, LineNo, Code, CoverageStatus, NoOfHits
    $codeLines = $xml.SelectNodes('//CodeLine')
    if (-not $codeLines -or $codeLines.Count -eq 0) {
        # Try alternate root element names
        $codeLines = $xml.SelectNodes('//CodeCoverageLines/CodeCoverageLine')
    }
    if (-not $codeLines -or $codeLines.Count -eq 0) {
        $codeLines = $xml.SelectNodes('//*[ObjectType and ObjectID and LineNo]')
    }
    
    foreach ($node in $codeLines) {
        $objectTypeRaw = $node.ObjectType
        $objectId = [int]$node.ObjectID
        $lineNo = [int]$node.LineNo
        
        # CoverageStatus: 0=Covered, 1=NotCovered, 2=PartiallyCovered
        $coverageStatus = 1  # Default to NotCovered
        if ($node.CoverageStatus) {
            $coverageStatus = [int]$node.CoverageStatus
        } elseif ($node.NoOfHits -and [int]$node.NoOfHits -gt 0) {
            $coverageStatus = 0  # Covered
        }
        
        $hits = 0
        if ($node.NoOfHits) {
            $hits = [int]$node.NoOfHits
        }
        
        # Handle both numeric and text object types
        $objectTypeId = 0
        $objectType = $objectTypeRaw
        
        if ($objectTypeRaw -match '^\d+$') {
            $objectTypeId = [int]$objectTypeRaw
            $objectType = if ($script:ObjectTypeMap.ContainsKey($objectTypeId)) { 
                $script:ObjectTypeMap[$objectTypeId] 
            } else { 
                "Unknown_$objectTypeId" 
            }
        } else {
            $objectType = $objectTypeRaw
            $objectTypeId = Get-ObjectTypeId $objectTypeRaw
        }
        
        $entry = [PSCustomObject]@{
            ObjectTypeId       = $objectTypeId
            ObjectType         = $objectType
            ObjectId           = $objectId
            LineNo             = $lineNo
            CoverageStatus     = $coverageStatus
            CoverageStatusName = if ($script:CoverageStatusMap.ContainsKey($coverageStatus)) {
                $script:CoverageStatusMap[$coverageStatus]
            } else {
                "Unknown_$coverageStatus"
            }
            Hits               = $hits
            IsCovered          = ($coverageStatus -eq 0 -or $coverageStatus -eq 2)
        }
        
        $coverageEntries.Add($entry)
    }
    
    Write-Host "Parsed $($coverageEntries.Count) coverage entries from XML file: $Path"
    return ,@($coverageEntries)
}

<#
.SYNOPSIS
    Parses a BC code coverage CSV file (XMLport 130470/130471 format)
.PARAMETER Path
    Path to the .dat CSV coverage file
.OUTPUTS
    Array of coverage entry objects
#>
function Read-BCCoverageCsvFile {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )

    $coverageEntries = [System.Collections.Generic.List[object]]::new()
    
    # BC coverage files can be UTF-16 (Unicode) or UTF-8 encoded
    # Try to detect based on BOM or content validation
    $content = $null
    $bytes = [System.IO.File]::ReadAllBytes($Path)
    
    # Check for UTF-16 LE BOM (FF FE)
    if ($bytes.Length -ge 2 -and $bytes[0] -eq 0xFF -and $bytes[1] -eq 0xFE) {
        $content = Get-Content -Path $Path -Encoding Unicode
    }
    # Check for UTF-8 BOM (EF BB BF)  
    elseif ($bytes.Length -ge 3 -and $bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF) {
        $content = Get-Content -Path $Path -Encoding UTF8
    }
    else {
        # No BOM - try UTF8 first (more common for text files without BOM)
        $content = Get-Content -Path $Path -Encoding UTF8
        
        # Validate first line looks like coverage data
        if ($content.Count -gt 0) {
            $firstLine = $content[0]
            $parts = $firstLine.Split(',')
            # If first line doesn't have 5 parts or second part isn't numeric, try Unicode
            if ($parts.Count -lt 5 -or $parts[1] -notmatch '^\d+$') {
                $content = Get-Content -Path $Path -Encoding Unicode
            }
        }
    }
    
    foreach ($line in $content) {
        # Skip empty lines
        if ([string]::IsNullOrWhiteSpace($line)) {
            continue
        }
        
        # Parse CSV: ObjectType,ObjectID,LineNo,CoverageStatus,NoOfHits
        # ObjectType can be numeric (5) or text (Codeunit, Table, etc.)
        $parts = $line.Split(',')
        
        if ($parts.Count -ge 5) {
            $objectTypeRaw = $parts[0].Trim()
            $objectId = [int]$parts[1]
            $lineNo = [int]$parts[2]
            $coverageStatus = [int]$parts[3]
            $hits = [int]$parts[4]
            
            # Handle both numeric and text object types
            $objectTypeId = 0
            $objectType = $objectTypeRaw
            
            if ($objectTypeRaw -match '^\d+$') {
                # Numeric object type ID
                $objectTypeId = [int]$objectTypeRaw
                $objectType = if ($script:ObjectTypeMap.ContainsKey($objectTypeId)) { 
                    $script:ObjectTypeMap[$objectTypeId] 
                } else { 
                    "Unknown_$objectTypeId" 
                }
            } else {
                # Text object type name - normalize and find ID
                $objectType = $objectTypeRaw
                $objectTypeId = Get-ObjectTypeId $objectTypeRaw
            }
            
            $entry = [PSCustomObject]@{
                ObjectTypeId   = $objectTypeId
                ObjectType     = $objectType
                ObjectId       = $objectId
                LineNo         = $lineNo
                CoverageStatus = $coverageStatus
                CoverageStatusName = if ($script:CoverageStatusMap.ContainsKey($coverageStatus)) {
                    $script:CoverageStatusMap[$coverageStatus]
                } else {
                    "Unknown_$coverageStatus"
                }
                Hits           = $hits
                IsCovered      = ($coverageStatus -eq 0 -or $coverageStatus -eq 2)
            }
            
            $coverageEntries.Add($entry)
        }
    }
    
    Write-Host "Parsed $($coverageEntries.Count) coverage entries from $Path"
    return ,@($coverageEntries)
}

<#
.SYNOPSIS
    Groups coverage entries by object (ObjectType + ObjectId)
.PARAMETER CoverageEntries
    Array of coverage entries from Read-BCCoverageFile
.OUTPUTS
    Hashtable keyed by "ObjectType.ObjectId" containing grouped entries
#>
function Group-CoverageByObject {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [array]$CoverageEntries
    )
    
    $grouped = @{}
    
    foreach ($entry in $CoverageEntries) {
        $key = "$($entry.ObjectType).$($entry.ObjectId)"
        
        if (-not $grouped.ContainsKey($key)) {
            $grouped[$key] = @{
                ObjectType   = $entry.ObjectType
                ObjectTypeId = $entry.ObjectTypeId
                ObjectId     = $entry.ObjectId
                Lines        = [System.Collections.Generic.List[object]]::new()
            }
        }
        
        $grouped[$key].Lines.Add($entry)
    }
    
    return $grouped
}

<#
.SYNOPSIS
    Calculates coverage statistics for a set of entries
.PARAMETER CoverageEntries
    Array of coverage entries
.OUTPUTS
    Object with TotalLines, CoveredLines, NotCoveredLines, CoveragePercent
#>
function Get-CoverageStatistics {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [array]$CoverageEntries
    )
    
    $totalLines = $CoverageEntries.Count
    $coveredLines = ($CoverageEntries | Where-Object { $_.IsCovered }).Count
    $notCoveredLines = $totalLines - $coveredLines
    $coveragePercent = if ($totalLines -gt 0) { 
        [math]::Round(($coveredLines / $totalLines) * 100, 2) 
    } else { 
        0 
    }
    
    return [PSCustomObject]@{
        TotalLines      = $totalLines
        CoveredLines    = $coveredLines
        NotCoveredLines = $notCoveredLines
        CoveragePercent = $coveragePercent
        LineRate        = if ($totalLines -gt 0) { $coveredLines / $totalLines } else { 0 }
    }
}

<#
.SYNOPSIS
    Gets the object type name from an ID
.PARAMETER ObjectTypeId
    The BC object type ID
.OUTPUTS
    String name of the object type
#>
function Get-ObjectTypeName {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [int]$ObjectTypeId
    )
    
    if ($script:ObjectTypeMap.ContainsKey($ObjectTypeId)) {
        return $script:ObjectTypeMap[$ObjectTypeId]
    }
    return "Unknown_$ObjectTypeId"
}

Export-ModuleMember -Function @(
    'Read-BCCoverageFile',
    'Read-BCCoverageXmlFile',
    'Read-BCCoverageCsvFile',
    'Group-CoverageByObject',
    'Get-CoverageStatistics',
    'Get-ObjectTypeName',
    'Get-ObjectTypeId'
)
