<#
.SYNOPSIS
    Parses Business Central code coverage .dat files
.DESCRIPTION
    Reads and parses the code coverage output files generated by BC CodeCoverage exporters.
    File format is CSV without headers: ObjectType,ObjectID,LineNo,CoverageStatus,NoOfHits
    ObjectType can be text (Table, Codeunit, Page, etc.) or numeric ID.
    Encoding can be UTF-8 or UTF-16 LE.
#>

# Object type mapping from BC internal IDs to names
$script:ObjectTypeMap = @{
    1  = 'TableData'
    3  = 'Table'
    5  = 'Codeunit'
    6  = 'XMLport'
    7  = 'MenuSuite'
    8  = 'Page'
    9  = 'Query'
    14 = 'Report'
    22 = 'TableExtension'
    23 = 'PageExtension'
    35 = 'PageCustomization'
    37 = 'Enum'
    38 = 'EnumExtension'
    40 = 'Profile'
    42 = 'ControlAddIn'
    44 = 'PermissionSet'
    45 = 'PermissionSetExtension'
    46 = 'ReportExtension'
    47 = 'Interface'
}

# Coverage status mapping
$script:CoverageStatusMap = @{
    0 = 'Covered'
    1 = 'NotCovered'
    2 = 'PartiallyCovered'
}

# Reverse mapping from object type names to IDs
$script:ObjectTypeNameMap = @{
    'tabledata'              = 1
    'table'                  = 3
    'codeunit'               = 5
    'xmlport'                = 6
    'menusuite'              = 7
    'page'                   = 8
    'query'                  = 9
    'report'                 = 14
    'tableextension'         = 22
    'pageextension'          = 23
    'pagecustomization'      = 35
    'enum'                   = 37
    'enumextension'          = 38
    'profile'                = 40
    'controladdin'           = 42
    'permissionset'          = 44
    'permissionsetextension' = 45
    'reportextension'        = 46
    'interface'              = 47
}

<#
.SYNOPSIS
    Gets the object type ID from a name
.PARAMETER ObjectTypeName
    The object type name (e.g., "Table", "Codeunit")
.OUTPUTS
    Integer ID or 0 if not found
#>
function Get-ObjectTypeId {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ObjectTypeName
    )
    
    $lower = $ObjectTypeName.ToLower().Trim()
    if ($script:ObjectTypeNameMap.ContainsKey($lower)) {
        return $script:ObjectTypeNameMap[$lower]
    }
    return 0
}

<#
.SYNOPSIS
    Parses a BC code coverage .dat file
.PARAMETER Path
    Path to the .dat coverage file
.OUTPUTS
    Array of coverage entry objects with ObjectType, ObjectID, LineNo, CoverageStatus, Hits
#>
function Read-BCCoverageFile {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )

    if (-not (Test-Path $Path)) {
        throw "Coverage file not found: $Path"
    }

    $coverageEntries = @()
    
    # BC coverage files can be UTF-16 (Unicode) or UTF-8 encoded
    # Try to detect based on BOM or content validation
    $content = $null
    $bytes = [System.IO.File]::ReadAllBytes($Path)
    
    # Check for UTF-16 LE BOM (FF FE)
    if ($bytes.Length -ge 2 -and $bytes[0] -eq 0xFF -and $bytes[1] -eq 0xFE) {
        $content = Get-Content -Path $Path -Encoding Unicode
    }
    # Check for UTF-8 BOM (EF BB BF)  
    elseif ($bytes.Length -ge 3 -and $bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF) {
        $content = Get-Content -Path $Path -Encoding UTF8
    }
    else {
        # No BOM - try UTF8 first (more common for text files without BOM)
        $content = Get-Content -Path $Path -Encoding UTF8
        
        # Validate first line looks like coverage data
        if ($content.Count -gt 0) {
            $firstLine = $content[0]
            $parts = $firstLine.Split(',')
            # If first line doesn't have 5 parts or second part isn't numeric, try Unicode
            if ($parts.Count -lt 5 -or $parts[1] -notmatch '^\d+$') {
                $content = Get-Content -Path $Path -Encoding Unicode
            }
        }
    }
    
    foreach ($line in $content) {
        # Skip empty lines
        if ([string]::IsNullOrWhiteSpace($line)) {
            continue
        }
        
        # Parse CSV: ObjectType,ObjectID,LineNo,CoverageStatus,NoOfHits
        # ObjectType can be numeric (5) or text (Codeunit, Table, etc.)
        $parts = $line.Split(',')
        
        if ($parts.Count -ge 5) {
            $objectTypeRaw = $parts[0].Trim()
            $objectId = [int]$parts[1]
            $lineNo = [int]$parts[2]
            $coverageStatus = [int]$parts[3]
            $hits = [int]$parts[4]
            
            # Handle both numeric and text object types
            $objectTypeId = 0
            $objectType = $objectTypeRaw
            
            if ($objectTypeRaw -match '^\d+$') {
                # Numeric object type ID
                $objectTypeId = [int]$objectTypeRaw
                $objectType = if ($script:ObjectTypeMap.ContainsKey($objectTypeId)) { 
                    $script:ObjectTypeMap[$objectTypeId] 
                } else { 
                    "Unknown_$objectTypeId" 
                }
            } else {
                # Text object type name - normalize and find ID
                $objectType = $objectTypeRaw
                $objectTypeId = Get-ObjectTypeId $objectTypeRaw
            }
            
            $entry = [PSCustomObject]@{
                ObjectTypeId   = $objectTypeId
                ObjectType     = $objectType
                ObjectId       = $objectId
                LineNo         = $lineNo
                CoverageStatus = $coverageStatus
                CoverageStatusName = if ($script:CoverageStatusMap.ContainsKey($coverageStatus)) {
                    $script:CoverageStatusMap[$coverageStatus]
                } else {
                    "Unknown_$coverageStatus"
                }
                Hits           = $hits
                IsCovered      = ($coverageStatus -eq 0 -or $coverageStatus -eq 2)
            }
            
            $coverageEntries += $entry
        }
    }
    
    Write-Host "Parsed $($coverageEntries.Count) coverage entries from $Path"
    return $coverageEntries
}

<#
.SYNOPSIS
    Groups coverage entries by object (ObjectType + ObjectId)
.PARAMETER CoverageEntries
    Array of coverage entries from Read-BCCoverageFile
.OUTPUTS
    Hashtable keyed by "ObjectType.ObjectId" containing grouped entries
#>
function Group-CoverageByObject {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [array]$CoverageEntries
    )
    
    $grouped = @{}
    
    foreach ($entry in $CoverageEntries) {
        $key = "$($entry.ObjectType).$($entry.ObjectId)"
        
        if (-not $grouped.ContainsKey($key)) {
            $grouped[$key] = @{
                ObjectType   = $entry.ObjectType
                ObjectTypeId = $entry.ObjectTypeId
                ObjectId     = $entry.ObjectId
                Lines        = @()
            }
        }
        
        $grouped[$key].Lines += $entry
    }
    
    return $grouped
}

<#
.SYNOPSIS
    Calculates coverage statistics for a set of entries
.PARAMETER CoverageEntries
    Array of coverage entries
.OUTPUTS
    Object with TotalLines, CoveredLines, NotCoveredLines, CoveragePercent
#>
function Get-CoverageStatistics {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [array]$CoverageEntries
    )
    
    $totalLines = $CoverageEntries.Count
    $coveredLines = ($CoverageEntries | Where-Object { $_.IsCovered }).Count
    $notCoveredLines = $totalLines - $coveredLines
    $coveragePercent = if ($totalLines -gt 0) { 
        [math]::Round(($coveredLines / $totalLines) * 100, 2) 
    } else { 
        0 
    }
    
    return [PSCustomObject]@{
        TotalLines      = $totalLines
        CoveredLines    = $coveredLines
        NotCoveredLines = $notCoveredLines
        CoveragePercent = $coveragePercent
        LineRate        = if ($totalLines -gt 0) { $coveredLines / $totalLines } else { 0 }
    }
}

<#
.SYNOPSIS
    Gets the object type name from an ID
.PARAMETER ObjectTypeId
    The BC object type ID
.OUTPUTS
    String name of the object type
#>
function Get-ObjectTypeName {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [int]$ObjectTypeId
    )
    
    if ($script:ObjectTypeMap.ContainsKey($ObjectTypeId)) {
        return $script:ObjectTypeMap[$ObjectTypeId]
    }
    return "Unknown_$ObjectTypeId"
}

Export-ModuleMember -Function @(
    'Read-BCCoverageFile',
    'Group-CoverageByObject',
    'Get-CoverageStatistics',
    'Get-ObjectTypeName',
    'Get-ObjectTypeId'
)
